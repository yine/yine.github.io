<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FreeSWITCH模块类型</title>
      <link href="/2020/04/29/FreeSWITCH%E6%A8%A1%E5%9D%97%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/04/29/FreeSWITCH%E6%A8%A1%E5%9D%97%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="FreeSWITCH模块类型"><a href="#FreeSWITCH模块类型" class="headerlink" title="FreeSWITCH模块类型"></a>FreeSWITCH模块类型</h2><p>　　FreeSWITCH的内核特别稳定，而外部模块的接口也相当稳定，所以为我们开发自己的模块打下了良好的基础。在设计之初，Anthony Minessale 将外部模块分为13种类型，每种类型代表不同的应用方向，并且也设计了稳定的plugin接口。</p><p>FreeSWTICH的接口类型：</p><ul><li>SWITCH_ENDPOINT_INTERFACE /* endpoint modules, 主要实现各种通信协议，如SIP、H.232、Skype、XMPP等等*/</li><li>SWITCH_TIMER_INTERFACE /* 时钟接口，包括软时钟和硬时钟，FreeSWITCH自带一个soft timer */</li><li>SWITCH_DIALPLAN_INTERFACE /* dialplan modules, 用来控制呼叫流程的，比如在XML中编写流程的控制，或者自己定义一种文本语法，然后编写一个dialplan module用来解析这种流程控制的语法 */</li><li>SWITCH_CODEC_INTERFACE /* 编码模块，包括 G.722、G.729等，现在貌似还没有视频的编解码，有兴趣的朋友可以自己开发一个 */</li><li>SWITCH_APPLICATION_INTERFACE /* 应用模块，这种模块一般是用户定义的功能，比如说使用自己的短信猫发短信，那么就可以写一个APP，在dialplan中使用 */</li><li>SWITCH_API_INTERFACE /* API一般是在FreeSWITCH的shell中使用的，但是也可以通过特定方式在dialplan中使用，类似于APP modules */</li><li>SWITCH_FILE_INTERFACE /* 文件操作模块，暂时还没分析这个接口 */</li><li>SWITCH_SPEECH_INTERFACE /* TTS 模块，调用TTS引擎的API实现语音合成的功能，用户可以直接在dialplan中使用，比如将微软的SAPI实现TTS功能 */</li><li>SWITCH_DIRECTORY_INTERFACE /* 模块操作模块，暂时还没分析这个接口 */</li><li>SWITCH_CHAT_INTERFACE /* IM模块，暂时还没分析这个接口 */</li><li>SWITCH_SAY_INTERFACE /* 提示音多语言支持模块，FreeSWTICH有一些内置的提示音，一个say module实现一种语音的提示音播放，比如说mod_say_zh就是使用中文播放 “元”、”角”、“分”，而mod_say_en就是英文播放”dollar“、”cent“等 */</li><li>SWITCH_ASR_INTERFACE /* ASR模块，调用语音识别引擎API实现语音识别 */</li><li>SWITCH_MANAGEMENT_INTERFACE /* 暂时还没有分析这个接口 */</li></ul><p>　　上面这些接口，有的比较简单，比如TTS的，SAY模块（大部分常用的都内置了，无需再开发），Dialplan模块，也有部分比较复杂，比如Endpoint和ASR这两个就教负责一些。还有一些我还没有分析到，所以不太清楚其负责程度，等写到对应的模块再说吧。</p><p>　　其实说白了，C/C++的plugin/module framework无非就是函数指针，那么FreeSWITCH的module接口也是大量的使用了函数指针，以达到用户实现功能模块，FreeSWITCH Core负责调度的原则。</p><p>　　基本上会按照上面标志的顺序对FreeSWITCH的模块开发做一些简单的分析，然后再说一下开发中应该注意的地方（如果我做过对应模块），最后可能写一些简单的示例。</p>]]></content>
      
      
      <categories>
          
          <category> 开源软交换 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源软交换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeSWITH源码编译</title>
      <link href="/2020/04/17/FreeSWITH%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
      <url>/2020/04/17/FreeSWITH%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="源代码导读及编译指南"><a href="#源代码导读及编译指南" class="headerlink" title="源代码导读及编译指南"></a>源代码导读及编译指南</h1><p>好多朋友在讨论如何阅读源代码时，感觉最大的困扰并不是看不懂代码，而是不知道从哪里下手，就好像是老虎吃天——无从下口。是的，FreeSWITCH的源代码太长了，确实好像从哪里看好像都找不到源头。不过，也不要因此而望而却步。在看比较大型的项目时，尤其是对着不熟悉的功能和代码，总要经过这么一个过程。尤其是，有些朋友，在对FreeSWITCH本身还不熟悉的时候，就试图通过阅读源代码来了解系统的功能。个人认为那是本末倒置的方法，不可取。笔者一直坚持，要想阅读FreeSWITCH的源代码，先要阅读官方文档、如果感觉英文太难读，国内也有不少这方面的书籍，如：老杜的《FreeSWITCH权威指南》,老李也写过不少这方面的文章和电子书，自己多做实验，掌握了FreeSWITCH的基本功能，再来阅读源代码会容易入手一些。</p><p>当然，阅读源代码不仅仅是为了满足我们的好奇心——哪些功能是怎么实现的、系统还有何种没有公开（写到文档里）的功能等。更重要的是，如果我们熟悉了源代码，我们就可以修改它——不管是修复BUG、增加功能并为开源项目做贡献，还是修改源代码以适合你自己的需要，这些都能给你带来很好的成就感。</p><p>接下来，我们从准备源代码环境开始，由浅入深地进一步一步进入FreeSWITCH内部的神秘世界。</p><h2 id="准备FreeSWITH源代码环境"><a href="#准备FreeSWITH源代码环境" class="headerlink" title="准备FreeSWITH源代码环境"></a>准备FreeSWITH源代码环境</h2><p>首先，Clone FreeSWITCH源代码：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://freeswitch.org/stash/scm/fs/freeswitch.git<br></code></pre></td></tr></table></figure><p>要查看源代码，最好选择一个具有语法高亮功能的阅读器或编辑器。作者在一直使用的是比较厚重的Visual Studio不过它只能运行在Win下，也有其它跨平台的工具比如SublimeText，只不过它只有语法高亮，函数之前的依赖及跳转基本没有，当然也可以使用一些经典工具，如在UNIX类系统上使用vi/vim或Emacs。</p><h2 id="FreeSWITCH源代码目录结构"><a href="#FreeSWITCH源代码目录结构" class="headerlink" title="FreeSWITCH源代码目录结构"></a>FreeSWITCH源代码目录结构</h2><p>FreeSWITCH的源代码目录中，<code>src</code>目录中包含了绝大部分的源代码；<code>libs</code>目录下是一些第三方的库和模块，如<code>libs/sofia-sip</code>就是Nokia的SIP库。</p><p>在<code>src</code>目录中，<code>include</code>目录存放了系统大部分的头文件；不同模块的代码则分门别类的放到<code>mod</code>目录中不同的子目录中。系统的核心代码则直接在<code>src</code>目录中。</p><p>FreeSWITCH模块的源代码（<code>mod</code>目录）结构如下表所示：</p><p>目录             说明</p><hr><p><code>asr_tts</code>          语音识别及合成相关模块<br><code>dialplans</code>        Dialplan模块<br><code>endpoints</code>        Endpoint模块，如<code>mod_sofia</code><br><code>formats</code>          文件格式模块，如<code>mod_sndfile</code><br><code>loggers</code>          日志模块<br><code>sdk</code>              一些例子和宏<br><code>xml_int</code>          XML相关的模块<br><code>applications</code>     提供各种应用功能的模块，如<code>mod_dptools</code>和<code>mod_commands</code><br><code>directories</code>      LDAP<br><code>event_handlers</code>   事件处理模块<br><code>languages</code>        嵌入式语言模块<br><code>say</code>              不同语种的语言模块<br><code>timers</code>           时钟和定时器模块</p><p>上面不同的分类也与FreeSWITCH内部模块的抽象大致对应，但也有例外的情况，典型地，一些模块可能有多个接口（Interface）实现，这样的模块会根据其主要功能放到对应的目录中，有时就直接放到<code>applications</code>目录中，相当于该目录中有一些多功能的模块。但随着时间的推移，某些单功能的模块也可能会被增加一些新的功能和接口（Interface），变成多功能模块。</p><h2 id="FreeSWITCH源代码的编译"><a href="#FreeSWITCH源代码的编译" class="headerlink" title="FreeSWITCH源代码的编译"></a>FreeSWITCH源代码的编译</h2><p>关于FreeSWITCH的编译，我们主要以在Linux系统上的编译为例。Windows平台上一般很少用来做服务部署和执行，暂时略过。</p><h3 id="首次编译"><a href="#首次编译" class="headerlink" title="首次编译"></a>首次编译</h3><p>在编译源代码前，请确保按第3章中所讲的安装相关的依赖库及开发包。FreeSWITCH在开发中使用经典的<code>gcc</code>、<code>Makefile</code>及<code>automake</code>、<code>autoconf</code>等GNU工具链，因而在各种平台上都很容易地进行编译。</p><p>为了方便不了解这些GNU工具的读者，我们在此也顺便简单讲一下。</p><p>首先，大家知道，FreeSWITCH主要是用C和C++写的。编译C语言的程序一般需要<code>gcc</code>，如，如下命令会编译<code>test.c</code>并生成一个可以执行的二进制程序：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc test.c -o <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>当源代码数量过多时，一行一行的执行<code>gcc</code>就比较累了。因此，可以编写简单的Shell脚本或Makefile实现。Makefile是<code>make</code>工具使用的文件，它除了定义源文件到目标文件的编译方法外，还能定义这些文件的依赖关系。通过检查这些依赖关系，如果在下次编译时源文件没有修改过，则可以不用重复编译，因而可以大大加快编译速度。</p><p>不同平台上的工具链是不一样的，在Linux等开源平台上一般使用<code>gcc</code>，而在其他商业的UNIX系统上往往都有各厂商自己的编译工具链，因而一种称为<code>automake</code>的工具出现了。通过编写<code>configure</code>脚本，定义一些宏，可以在编译前自动检测当前的平台环境和工具链，以生成适当的Makefile。</p><p>当工程更大的时候，写<code>configure</code>脚本也是很累人的活，因而又有人发明了<code>autoconf</code>，通过定义更简单的宏，可以自动生成<code>configure</code>脚本。</p><p>总之，大家可以结合FreeSWITCH的编译过程深入理解一下。</p><p>首先，如果你是从Git仓库中Clone的源代码，需要先执行一下<code>bootstrap.sh</code>。它会初始化一些文件。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./bootstrap.sh<br></code></pre></td></tr></table></figure><p>如果是直接下载的源代码Tar包，则不需要这一步，因为源代码在<code>tar</code>之前就已经执行过该步骤了。</p><p>接下来，执行<code>configure</code>，它会生成<code>Makefile</code>：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure<br></code></pre></td></tr></table></figure><p><code>configure</code>有很多参数，其中比较常用的是<code>prefix</code>参数，用于将FreeSWITCH安装到指定的目录下（FreeSWITCH默认的安装目录是<code>/usr/local/freeswitch</code>），如：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure --prefix=/usr/<span class="hljs-built_in">local</span>/freeswitch2<br>./configure --prefix=/opt/freeswitch<br></code></pre></td></tr></table></figure><p><code>configure</code>执行完毕后，将产生<code>Makefile</code>，以及一个<code>modules.conf</code>文件。<code>modules.conf</code>用于控制在编译阶段要自动编译哪些模块。如果你需要这些模块，则可以编辑该文件，并去掉前面的”<code>#</code>“号注释，如：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ head modules.conf<br><span class="hljs-comment">#applications/mod_abstraction</span><br><span class="hljs-comment">#applications/mod_avmd</span><br><span class="hljs-comment">#applications/mod_blacklist</span><br><span class="hljs-comment">#applications/mod_callcenter</span><br><span class="hljs-comment">#applications/mod_cidlookup</span><br>applications/mod_cluechoo<br>applications/mod_commands<br>applications/mod_conference<br><span class="hljs-comment">#applications/mod_curl</span><br>applications/mod_db<br></code></pre></td></tr></table></figure><p>如果不知道哪些模块是干什么的，可以暂且不管这个文件。到以后也可以再单独编译某些模块。</p><p>接下来，执行<code>make</code>，它将根据<code>Makefile</code>进行编译</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure><p>编译成功后，执行如下命令将程序安装到相应的位置。</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make install<br></code></pre></td></tr></table></figure><p>注意，需要确认要安装的目标位置有写入的权限，如果这些命令都是以<code>root</code>执行的，那你不会遇到权限的问题，但如果你是以普通用户执行的，就可能遇到权限的问题。所以，如果有权限的问题，可以尝试用<code>root</code>进行安装：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo make install<br></code></pre></td></tr></table></figure><p>或者，也可以通过如下方案以普通用户的身份安装，如，以<code>freeswitch</code>用户安装，假设你现在登录的用户就是<code>freeswitc</code>h：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mkdir /usr/<span class="hljs-built_in">local</span>/freeswitch               <span class="hljs-comment"># 用root身份创建目录</span><br>sudo chown freeswitch /usr/<span class="hljs-built_in">local</span>/freeswitch    <span class="hljs-comment"># 把目录的属主改为freeswitch</span><br>make install                                   <span class="hljs-comment"># 用freeswitch普通用户身份安装即可</span><br></code></pre></td></tr></table></figure><h3 id="增量编译"><a href="#增量编译" class="headerlink" title="增量编译"></a>增量编译</h3><p>有时候，我们修改了源文件，需要再次编译。在没有修改<code>autoconf</code>、<code>automake</code>相关的编译规则的话，直接执行<code>make</code>就行了：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure><p>或者，也可以直接执行</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make install<br></code></pre></td></tr></table></figure><p><code>make</code>会检查全部的规则，并决定哪些需要重新编译，这还是比较耗时的。如果你知识你仅仅修改了哪些模块的话，可以直接编译该模块，如：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make mod_sofia<br>make mod_sofia-install<br></code></pre></td></tr></table></figure><p>使用这种方法也可以编译默认没有编译过的模块，如<code>mod_shout</code>模块提供mp3录、放音的支持，它默认是不被编译的，可以用以下命令安装：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make mod_shout-install<br></code></pre></td></tr></table></figure><p>当然，在大多数情况下，你也可以直接进入相关的模块目录下，执行<code>make</code>。如：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> src/mod/endpoints/mod_sofia<br>make install<br></code></pre></td></tr></table></figure><p>如果你改了核心的代码，则可以执行</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make core-install<br></code></pre></td></tr></table></figure><h3 id="常见问题及最佳实践"><a href="#常见问题及最佳实践" class="headerlink" title="常见问题及最佳实践"></a>常见问题及最佳实践</h3><p>如果在编译过程中出现某个或某些模块编译不通过的情况，可以先在<code>modules.conf</code>中将该模块注释掉，等全部的编译通过后，再单独检查该模块有什么问题。</p><p>如果跟作者一样，你经常在不同的分支中切来切去，则如果分支差异比较大时编译系统中的目标文件可能会乱掉。这是可能是编译规则设置的问题，但FreeSWITCH项目太大了，因而，作者经常在不同的目录中编译，如，下列命令编译最新的master版本到默认位置：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://freeswitch.org/stash/scm/fs/freeswitch.git freeswitch-master<br><span class="hljs-built_in">cd</span> freeswitch-master<br>./bootstrap.sh &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>编译1.10.1版本并安装到<code>/usr/local/freeswitch-1.10.1</code>：</p><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://freeswitch.org/stash/scm/fs/freeswitch.git freeswitch-1.10.1<br><span class="hljs-built_in">cd</span> freeswitch-1.10.1<br>git checkout v1.10.1.stable<br>./bootstrap.sh &amp;&amp; ./configure --prefix=/usr/<span class="hljs-built_in">local</span>/freeswitch-1.10.1<br>make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>通过这种方式，以后在维护多个分支时就不会混乱了，而且，如果有必要的话，也可以同时在一台主机上同时启动不同版本的FreeSWITCH实例。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们主要讲了如何获取及编译FreeSWITCH代码，这样大家就可以在阅读源代码的同时尝试改一些地方（至少，可以在某些关于的地方加一些日志输出的语句），并编译执行看一下效果。阅读永远是枯燥乏味的，只有配合一定的实践，让代码“动”起来，才会有意思。</p>]]></content>
      
      
      <categories>
          
          <category> 开源软交换 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源软交换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github上的第一次写作</title>
      <link href="/2020/04/14/github%E4%B8%8A%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%99%E4%BD%9C/"/>
      <url>/2020/04/14/github%E4%B8%8A%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%99%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>开启一个全新的旅程, GO!</p><h1 id="大标题"><a href="#大标题" class="headerlink" title="大标题"></a>大标题</h1><p>test</p><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>test</p><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>test</p>]]></content>
      
      
      <categories>
          
          <category> 写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 写作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/04/12/hello-world/"/>
      <url>/2020/04/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
